# SOLID и другие принципы ОО-дизайна

По мере знакомства с языком программирования, решаемые задачи становятся все больше, а кодовая база решения - сложнее. В
случае с любым реальным проектом ситуация усложняется тем, что кодовую базу нужно развивать и поддерживать в течение 
длительного времени - лет или десятилетий.

На фоне этого повышается ценность качества и структурированности кода, ценность правильного выбора архитектурных 
подходов и прочих вещей, по которым можно условно разделить учебное "программирование" и разработку программного 
обеспечения.

Сегодня речь пойдет о наборе правил, которые часто объединяют в группу под названием "**Принципы 
объектно-ориентированного дизайна**". Большая часть из них достаточно простые и актуальны не только для ООП, 
какие-то - более специфичные и сложные для восприятия. Тем не менее, представленный ниже набор - классический и 
может быть полезен как в практических целях, так и на собеседованиях.

> Несмотря на общее название, ассоциирующее эти принципы с ООП, большинство из них применимо и в других парадигмах 
> программирования. А некоторые относятся к проектированию в широком смысле, не будучи чем-то специфичным именно для 
> разработки ПО.

## DRY

**Don’t repeat yourself** - **DRY** - "Не повторяйтесь".

Данный принцип регламентирует переиспользуемость кода через выделение блоков, которые нужны более чем в одном месте 
системы, в отдельные методы. Таким образом при необходимости изменения такого блока, его достаточно изменить 
единожды, не дублируя изменения в различных частях системы.

С этим принципам, например, связано выделение предупреждения в IDEA и других IDE, в ситуациях, когда среда 
разработки фиксирует несколько идентичных строк кода в различных частях проекта.

Соблюдение принципа упрощает поддержку кодовой базы. Ведь кроме непосредственной ручной работы по изменению одного и 
того же кода в нескольких местах, всегда сохраняется риск не актуализировать один и нескольких дублирующихся 
участков, в результате чего отдельные части системы начнут работать некорректно.

В качестве упрощенного примера использования принципа на практике можно описать следующую ситуацию.

Допустим, в нескольких частях проекта, логически не связанных между собой, необходимо рассчитывать площадь 
треугольника, опираясь на длины его сторон. Иными словами, необходимо реализовать в коде
[формулу Герона](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D1%83%D0%BB%D0%B0_%D0%93%D0%B5%D1%80%D0%BE%D0%BD%D0%B0).

Если каждый раз, когда потребуется реализовать такое вычисление вновь, просто копировать код расчета и вставлять его 
в новом месте, со временем можно столкнуться с проблемами - если в коде расчета выявится ошибка или по каким-то 
причинам потребуется заменить формулу расчета на иную, придется заменять код в каждом месте, где формула была 
применена. Если же расчет площади был своевременно выделен в отдельный метод отдельного класса (или хотя бы 
отдельный метод, если все применения находятся в пределах одного класса) - достаточно будет изменить код единожды, 
не перетряхивая половину проекта.

> Существует и антипринцип, указывающий на нарушение DRY при разработке - WET - write everything twice (пишите все 
> дважды) или же we enjoy typing (нам нравится печатать).

## KISS

**Keep it simple, stupid** - **KISS** - "Делай проще, тупица".

Принцип регламентирует отказ от переусложнения или overengineering'а. Как бы очевидно это не звучало, на практике 
можно часто встретить громоздкие и избыточные решения, которые стали таковыми по множеству причин. Ниже описано 
несколько примеров, которые в той или иной степени знакомы большинству разработчиков:

- _Дед терпел и нам велел_. Некая бизнес-функция была реализована во времена, когда текущая команда проекта ходила под 
  стол пешком. С тех пор технологии развивались, видение бизнес-функции менялось, как и требования к ней. Но вместо 
  того, чтобы в какой-то момент переосмыслить реализацию функции и написать код заново, каждый раз в него вносятся 
  мелкие правки и доработки, постепенно превращая реализацию во Франкенштейна, обвязанного кучей if'ов, с целью 
  сохранения ядра первоначального решения. Это может происходить как от слабого понимания командой изначального 
  решения и следующего за этим страха что-то сломать, так и из-за объемности решения и нехватки ресурсов на его 
  рефакторинг;
- _Один метод, чтобы править всеми_. Универсальное, как швейцарский нож, решение вместо набора отдельных 
  самостоятельных решений. Условно, написан один метод, определяющий формулу расчета площади на основе входных данных
  и применяющий ее. С одной стороны, можно вызвать один метод и получить корректный результат и для треугольника, и для 
  круга, и для прямоугольника, и для... С другой стороны, зачем? Вполне вероятно, что везде, где метод используется,
  известен тип фигуры. И вместо громоздкого метода с динамическим определением способа расчета и его применения
  (возможно, не всегда эффективного из-за избыточной обобщенности), можно выделить несколько лаконичных методов под 
  различные фигуры и использовать их по мере необходимости. Решение станет проще и, возможно, эффективнее;
- _Я у мамы оракул_. Приступая к реализации, разработчик постарался учесть в своем решении все - высокую нагрузку на 
  разрабатываемый сервис, пожелания заказчика, которые, возможно, поступят в работу через год, оптимизацию алгоритма 
  под все пограничные ситуации. Результатом может стать громоздкий код, отдельные нюансы работы которого даже автор 
  забудет к концу реализации задачи. С большой долей вероятности, на практике понадобится лишь малая часть подстеленной 
  автором соломы, а больше всего проблем при эксплуатации возникнет не там, где предполагалось. Лет через 10 этот 
  код превратится в то, что описывает пункт 1. 

Подводя итог, каждое разрабатываемое решение должно стремиться к простоте и лаконичности.

При этом стоит решать непосредственно поставленную задачу, не фантазируя за заказчика. Описанное в последнем из 
примеров выше чаще всего происходит из-за искренней заботы о разрабатываемом продукте и попытки сделать как можно лучше.
Но хорошее простое решение всегда можно расширить или переосмыслить. Заранее переусложненная, даже из лучших 
побуждений, каша тяжело поддается дальнейшей доработке и поддержке.

## YAGNI

**You aren't gonna need it** - **YAGNI** - "Вам это не понадобится".

В разрезе разработки этот принцип можно рассматривать как продолжение мысли из завершающей части предыдущего пункта. 
Если что-то не описано в требованиях к системе - не стоит это реализовывать в надежде, что это пригодится в дальнейшем.

Кроме того, что на подобную разработку будут затрачены ресурсы команды, зачастую такая разработка, особенно, если 
она касалась добавления новой функциональности, сузит пространство для маневра в части дальнейшего развития системы 
или подсистемы, где была реализована - ведь придется учитывать совместимость с разработанным "про запас".

Чаще данный принцип актуален для людей, которые отвечают за добавление требований к продукту - product owner'ов и 
бизнес-аналитиков. Но в технической части разработки для него также есть место - сделанные заранее заделы под 
расширение (скажем, иерархия классов вместо одного класса - вдруг потребуются альтернативные реализации), 
утилитные методы, добавленные еще до появления необходимости в них (все равно же что-то добавляю в этот класс - 
добавлю и это) и иные проявления излишней предусмотрительности. 

## SOLID

В отличие от предыдущих принципов, в SOLID зашифрована не фраза, а название пяти принципов - по одному на каждую букву.
И эти принципы действительно актуальны в первую очередь для объектно-ориентированной парадигмы.

### Single responsibility principle

**Single responsibility principle** или **Принцип единственной ответственности** утверждает, что класс должен иметь 
лишь одну причину для изменения.

Иными словами, класс должен отвечать только за что-то одно - иметь единственную ответственность. И лишь изменение 
требований к тому, за что отвечает класс, должно быть причиной изменения кода в этом классе.

В широком смысле, этот принцип следует из самой концепции ООП - каждый класс описывает некую одну сущность с 
ее данными и функциональностью. Но практика разработки часто заставляет работать с достаточно абстрактными 
сущностями, зоны ответственности которых не очевидны новичкам. Отсюда часто следуют достаточно большие классы, 
включающие в себя манипуляцию многими сущностями сразу.

Достаточно распространенный пример - некий сервис для работы с бизнес-сущностью, хранимой в БД. Скажем, 
`TicketService` для манипуляции билетами на самолет. Поскольку сами билеты хранятся в базе данных, велик соблазн 
описать в одном классе как бизнес-логику для работы с билетами, так и код, отвечающий за сохранение и извлечение 
данных из БД.

Описанное будет нарушением принципа единой ответственности - при корректной реализации отдельно должен существовать 
класс-сервис, отвечающий, скажем, за привязку билета к пассажиру, отмену этой привязки и другие бизнес-функции, а 
отдельно - класс-репозиторий (или [DAO](https://ru.wikipedia.org/wiki/Data_Access_Object), в зависимости от 
выбранного подхода), которому сервис будет делегировать задачи по коммуникации с БД относительно сущности "Билет".

Таким образом получится, что бизнес-логика инкапсулирована в классе-сервисе и является его ответственностью, а 
логика по работе с БД является ответственностью репозитория и инкапсулирована в нем.

К сожалению, сам по себе принцип единой ответственности не защищает от создания избыточно крупных классов - ведь 
ответственность может описываться многословно или же быть достаточно широкой в силу специфики объекта. В таком 
случае важно корректно определить возможность разбиения того, что мы понимаем под единой ответственностью на 
несколько более мелких блоков и разбить класс на несколько. Вопрос границ зоны ответственности отчасти философский, но 
имеющий значительное влияние на качество решения.

### Open-closed principle

**Open-closed principle** или **Принцип открытости/закрытости** говорит, что сущности (классы, модули, функции и т.д.)
должны быть открыты для расширения, но закрыты для изменения.

В изначальном видении этот принцип указывал, что существующие классы могут изменяться лишь для исправления ошибок, а 
при необходимости добавления новой функции или изменения существующей должны быть реализованы новые классы, при 
необходимости - с использованием кода существующего через механизм наследования.

В более поздней трактовке считается допустимым изменение существующего класса при сохранении его интерфейса. То есть 
при изменении существующих методов класса не должны изменяться сигнатуры и возвращаемые значения публичных методов. 
Также считается допустимым добавление новых функций в существующий класс - ведь это никак не ломает использование
существующих.

> В описанной ситуации все становится понятнее, если весь публичный API (все публичные методы и поля) 
> регламентируются интерфейсом, который реализует класс. Но на практике это не всегда целесообразно, особенно, если 
> у интерфейса существует лишь единственная реализация.
> 
> Зачастую, достаточно подразумевать существование "интерфейса", не вводя его в кодовую базу. Фактически это будет 
> означать запрет на изменение сигнатур публичных методов, упомянутый выше. По такой же логике может быть 
> недопустимо изменение сигнатур `package-private` и `protected` методов - в пределах иерархии классов или пакета 
> эти методы тоже можно рассматривать как публичный API.  

Так или иначе, основная цель принципа - исключить ситуации, когда изменение существующего класса (или метода) 
заставляет вносить правки в код, использующий измененный класс (или метод).

### Liskov substitution principle

**Liskov substitution principle** или **Принцип подстановки Барбары Лисков** регламентирует, что функции, которые
используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Иными словами, при использовании наследования всегда должны сохраняться контракты, регламентированные в базовом 
классе - дочерний класс не должен нарушать поведения родительского. На уровне синтаксиса в большинстве случаев от 
этого защитит сам компилятор - скажем, класс не может реализовать интерфейс, не определив поведение для всех 
существующих методов.

Но с точки зрения принципа важно не только сохранение синтаксической корректно, но также и семантическое соблюдение 
контракта. Скажем, именно то, что во всех реализациях `List` метод `E get(int index)` возвращает объект списка по 
индексу, позволяет нам в качестве возвращаемых типов и параметров метода использовать именно `List`, а не конкретную 
реализацию. Поскольку не имеет значения, какая именно реализация будет использована - `get()` и иные методы делают 
именно то, что регламентировано контрактом.

> Строго говоря, у описанного выше есть очевидное исключение. Даже для `List` мы можем вспомнить об имьютабельных 
> списках, в которых методы изменения элементов (`add()` и другие) определяются как:
> 
> ```java
> throw new UnsupportedOperationException();
> ```
> 
> Фактически, это нарушение принципа подстановки Лисков. Но это неизбежно для узконаправленных классов или, наоборот,
> слишком широких интерфейсов, в которых отдельные наследники не могут в полной мере реализовать весь 
> контракт в силу физических или иных ограничений. Примеры последнего часто можно встретить в иерархиях, так или 
> иначе относящихся к операциям ввода-вывода.  

### Interface segregation principle

**Interface segregation principle** или **Принцип разделения интерфейса** говорит о том, что сущности не должны 
зависеть от методов, которые они не используют.

Проще говоря, вместо разработки крупного интерфейса с множеством методов стоит по возможности выделять несколько более 
маленьких интерфейсов. Это позволяет строить более гибкие иерархии и хорошо укладывается в принцип единой 
ответственности - зачастую избыточно большой интерфейс получается в ситуациях, когда он объединяет в себе несколько 
ответственностей.

Программно большинство объектно-ориентированных языков позволяют без проблем реализовывать этот принцип через 
механизмы наследования интерфейсов и множественного наследования интерфейсов.

На практике это позволяет более гибко регламентировать использование того или иного инструментария. Так, в 
возвращаемом типе метода или его параметре в зависимости от ситуации мы можем указать, например, `Collection`, 
`List` или `Deque`, но во всех случаях при этом фактически использовать `LinkedList` для работы с элементами. 
Правильный же выбор интерфейса как упростит использование принципа подстановки Лисков (при необходимости можно будет 
использовать другую коллекцию/список/двунаправленную очередь), так и укажет другим разработчикам на то, какой API мы 
предлагаем использовать для работы с коллекцией, которую мы ожидаем на вход/возвращаем из метода.

### Dependency inversion principle

Определение **Dependency inversion principle** или **Принцип инверсии зависимостей** содержит две части:

1. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций;
2. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Первое определение как регламентирует выделение публичного API через интерфейсы (как было упомянуто выше, далеко не 
всегда необходимо выделять их синтаксически), так и указывает на семантическое главенство более высокоуровневых 
частей системы. Вполне логично, что, например, сервисный слой не должен быть как-либо ограничен особенностями слоя 
репозитория - ведь первый решает фактические проблемы бизнеса, а второй является скорее инфраструктурным 
обеспечением сохранения бизнес-сущностей в БД. Этот пример достаточно обычно достаточно очевиден новичкам, хоть и 
несколько спорный с точки зрения корректности именно как примера инверсии зависимостей. Более корректный пример: было бы
странно, если бы конкретная реализация JPA была как-либо ограничена каким-то отдельным драйвером (реализацией) JDBC.

Трактовка второй части определения часто лежит в плоскости проектирования публичного API и утверждает, что сам 
интерфейс не должен зависеть от реализаций. В максимально упрощенном виде, параметры, возвращаемые типы методов и 
параметризация интерфейсов также должна быть представлены интерфейсами или иными базовыми типами. Иначе вся иерархия 
классов может оказаться избыточно ограничена привязкой к каким-то отдельным сущностям. Так, некорректно было бы
спроектировать `List`, ограничив элементы только строками. Пример весьма утрированный, но наглядный.   

## Заключение

Писать работающий код можно по-разному. Описанные выше принципы регламентируют правила, которые должны привести к 
тому, что код не только будет закрывать сиюминутные потребности, но также будет расширяем и поддерживаем в течение 
долгого времени.

За время существования индустрии, сформировалось множество правил и подходов, регламентирующих непосредственно 
написание кода, проектирование информационных систем - от глобального уровня до проектирования отдельных модулей, 
классов, методов и их взаимодействия. Даже написано множество статей и книг, содержащих признаки, что код пора 
переписывать. По совокупности все это дает различные наборы правил, которые зачастую не касаются конкретных языков и 
технологий, но при этом обязательных к осознанию и применению разработчиками. В данной статье описаны лишь немногие 
из них - наиболее широко известные.

Задача минимум - применять эти правила по отношению к своему коду или коду своей команды. Задача максимум - навык 
эффективного использования таких правил для аргументации в профессиональных дискуссиях и на собеседованиях.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
