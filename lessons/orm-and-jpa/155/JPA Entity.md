# JPA Entity

Сегодня мы познакомимся с одной из краеугольных концепций JPA - **сущностью** (она же **Entity**).

Entity - это класс, которые в JPA являются отражениями конкретных таблиц. Объекты такого класса могут соотноситься с
конкретными строками таблицы.

Основная задача текущей статьи - показать, как сконфигурировать класс сущности, какие ограничения существуют у
данных классов. Но этого не хватит, чтобы взаимодействовать с помощью сущностей с базой данных, поэтому небольшая
часть кода в примерах останется непонятной до следующей статьи.

Но обо всем по порядку.

## Актуальность

На данном этапе может возникнуть вопрос: в чем разница с теми классами, которые мы использовали для маппинга записей
из БД при работе через JDBC? Ведь на первый взгляд звучит весьма похоже.

Техническая часть ответа на этот вопрос прояснится в пунктах ниже, но есть и важные особенности в части самой
концепции ORM. Она предполагает создание "виртуальной объектной БД". И сущности в этой виртуальной БД должны
определенным образом эмулировать взаимоотношения между объектами - например, связи объектов по аналогии со связями
строк в таблицах.

Кроме того, JPA сильно отличается от того, что мы видели ранее, в части работы с транзакциями. Подробнее мы будем
обсуждать это в следующей статье. Но суть заключается в том, что у нас появляется дополнительный слой абстракции,
который многие вещи, ассоциируемые с базой данных и транзакцией, оставляет на уровне Java-логики, из-за чего JPA
необходимы различные маркеры, позволяющие понимать, как взаимодействовать с теми или иными классами, как работать с
определенными полями - отвечающими за primary key, связи с другими таблицами (сущностями) и другими специфическими
атрибутами.

Наконец, сам маппинг записей в сущности и колонок таблицы в поля JPA реализует автоматически, не заставляя
разработчика писать конвертеры из `ResultSet` в целевые классы. И это тоже накладывает свои ограничения, как и любая
иная подобная автоматизация.

По совокупности описанное может выглядеть громоздко, но на деле все сводится к набору простых правил и аннотаций,
которые покрывают абсолютное большинство типовых сценариев. Реализация подобной логики действительно непростая, но
она скрыта внутри JPA и Hibernate (или иного провайдера).

## Технические особенности

Entity - это [POJO](https://ru.wikipedia.org/wiki/POJO), который используется для представления о строке таблицы в JPA,
и соответствует ряду условий:

- Сам класс аннотирован `@Entity`. С большего данную аннотацию можно считать маркером для JPA;
- Класс должен содержать `public` или `protected` конструктор без параметров. JPA создает entity-объекты через
  рефлексию, из-за чего ей нужен некий единый для любого entity-класса способ создания объекта;
- Класс не должен быть `final`, его поля, сопоставляемые с колонками таблицы, тоже не должны быть `final`. Это
  связано в первую очередь с тем, что JPA создает proxy-типы, базируясь на наследовании от entity-класса. Что в свою
  очередь связано с особенностями загрузки данных из строк и работой со связанными объектами. Подробнее к этой теме
  мы вернемся в одной из следующих статей;
- Класс должен иметь поле (или поля), представляющее идентификатор объекта - аналог PK в таблице. Такое поле (для
  составного PK - поля) должно быть аннотировано `@Id`.

Если вы ранее работали с БД через JDBC - с большой долей вероятности вы сможете переделать ваши классы-модели в
Entity просто добавив несколько аннотаций.

Ниже рассмотрим пример создания entity-класса и постараемся разобраться с ролью тех или иных конструкций.

Допустим, мы имеем следующую таблицу:

```sql
create table person (
                      id                      bigserial           primary key,
                      full_name               varchar(255)        not null,
                      age                     int                 not null,
                      gender                  varchar(10)         not null,
                      favorite_colors         text[],
                      created                 timestamp           not null,
                      updated                 timestamp
);
```

И планируем работать с ней через JPA. Также нам необходим в Java какой-то метод, который будет предоставлять
информацию о любимых цветах человека (`favorite_colors`) в виде строки.

Мы можем реализовать следующий класс:

```java
@Entity
@Table(name = "person")
public class PersonEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Column(name = "full_name", nullable = false)
    private String name;

    @Column(nullable = false)
    private int age;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private GenderType gender;

    @Column(name = "favorite_colors")
    private List<String> favoriteColors = new ArrayList<>();

    @Transient
    private String colorsString;

    private LocalDateTime created;

    private LocalDateTime updated;

    public String getColorsAsString() {
        return colorsString != null
                ? colorsString
                : String.join(", ", favoriteColors);
    }

    @PrePersist
    public void prePersist() {
        created = LocalDateTime.now();
    }

    @PreUpdate
    public void preUpdate() {
        updated = LocalDateTime.now();
    }
    
    // Getter'ы и Setter'ы
}
```

```java
public enum GenderType {
    MALE, FEMALE, UNDEFINED;
}
```

Постараемся разобраться, что к чему.

### Маппинг таблицы

Чаще всего имя класса-сущности делают эквивалентным имени таблицы, если опустить регистр. Тогда маппинг будет
происходить автоматически. Например, если бы наш класс назывался `Person`, он бы автоматически соотносился с таблицей
`person`.

Также есть различный инструментарий JPA-провайдеров, который позволяет сконфигурировать стандартные подстановки -
например, перевод camelCase в snake_case и наоборот, добавление и удаление каких-то стандартных префиксов в имени и
так далее. В таком случае маппинг тоже будет происходить автоматически.

> Например, в Hibernate за это отвечает `PhysicalNamingStrategy` - можно использовать существующие имплементации и
> реализовать свою и указывать в конфигурации.
>
> В пределах курса в это углубляться не будем - механизм достаточно простой и при необходимости может быть освоен
> самостоятельно.

Но если нам нужен маппинг на таблицу с нестандартной схемой или имя класса по каким-то причинам не может быть
автоматически сопоставлено с именем таблицы - нам потребуется аннотация `@Table`.

В примере выше она отвечает за то, чтобы явно указать классу `PersonEntity` сопоставление с таблицей `person`.

Кроме имени таблицы `@Table` позволяет определить следующие атрибуты:

- `catalog`. Каталог является более крупной единицей иерархии БД, чем схема. То есть некая группа схем. В PostgreSQL
  отсутствует;
- `schema`. Схема БД. С этим атрибутом придется взаимодействовать, если нужная таблица лежит не в схеме по умолчанию.
  Для PostgreSQL схемой по умолчанию будет `public`;
- `uniqueConstraints`. Провайдеры JPA могут обеспечивать генерацию или валидацию DDL. Данный атрибут позволяет
  указать уникальные констрэинты для соответствующей таблицы. Также их можно указать для информационных целей, чтобы
  не вынуждать разработчика получать эту информацию из миграций или структуры БД. Поскольку обычно генерация DDL не
  используется, чаще этот атрибут будет выполнять именно функцию информирования;
- `indexes`. Атрибут для указания индексов таблицы. Логика та же, что и в предыдущем случае.

### Работа с Primary Key

Поскольку логика JPA во многом крутится вокруг "виртуальной БД", нам необходимо сообщить фреймворку, что
является первичным ключом сущности и каким образом он должен формироваться.

Для указания, какие поля соотносятся с колонками PK достаточно использовать аннотацию `@Id`. Она является маркерной,
но накладывает определенные ограничения на типы данных, с которыми может работать:

- Примитивные типы;
- `String`;
- `UUID`;
- `BigDecimal` и `BigInteger`;
- `java.util.Date` или его наследник из JDBC - `java.sql.Date`.

> Если необходим композитный PK - потребуется познакомиться с более специфичными аннотациями - `@IdClass` и
> `@EmbeddedId`.

Но чаще всего промаркировать колонку как PK недостаточно - необходимо еще указать, какие правила формирования
значения PK должны быть использованы. Для этого существует аннотация `@GeneratedValue`. Она позволяет указать
в атрибутах стратегию, которую JPA будет применять для первичного ключа:

- `AUTO`. Делегирует определение конкретной стратегии провайдеру и базе данных. Hibernate в своей реализации
  опирается на тип поля. Для `UUID` будет генерировать новый UUID (детали ниже), для иных типов поведение будет
  зависеть от значения второго атрибута `@GeneratedValue` - `generator`;
- `UUID`. В качестве PK будет использоваться UUID-значение. Этот стандарт позволяет генерировать уникальное значение
  и широко используется в распределенных системах. Размер значения - 16 байт, что фактически означает множество в
  2¹²⁸ или 340 ундециллионов уникальных значений. Плюс данного подхода в том, что генерация id не требует обращения к
  БД, минус - размер (16 байт в виде UUID, 32-36 символов в строковом представлении, в зависимости от формата).
  Кроме того, не все СУБД умеют эффективно работать с UUID;
- `IDENTITY`. Наиболее распространенный формат для числовых id. Фактически делегирует заполнение значения базе
  данных. В большинстве случаев это означает, что будет использовать стандартная последовательность для PK таблицы.
  Для PostgreSQL подходит в случае использования serial-типов, но фактически должен работать и при наличии любой
  привязанной к PK последовательности;
- `SEQUENCE`. Позволяет использовать любую последовательность. Требует указания имени генератора (второй атрибут
  `@GeneratedValue`). В наиболее распространенном случае означает необходимость использовать для колонки
  `@SequenceGenerator`, в котором будет описана конфигурация генератора - например, его название в БД. Имеет большую
  гибкость и не требует явной вставки строки в таблицу, чтобы получить ее id, поскольку знает имя
  последовательности и может работать с ней через `nextval()` или иные нативные механизмы работы с
  последовательностью в СУБД;
- `TABLE`. Данный подход основан на отдельной таблице идентификаторов. В наиболее классическом сценарии требует
  использования `@TableGenerator`. Подход во многом схож с `SEQUENCE`, но за счет отдельной таблицы
  позволяет сохранить информацию о том, какой сущности был присвоен конкретный идентификатор. Весьма специфичный
  сценарий, но теоретически может быть полезен в целях аудита или иных ситуациях, когда одна последовательность
  используется для PK нескольких таблиц и необходимо знать, для какой таблицы было сгенерировано конкретное значение.

### Маппинг полей и колонок

> Этот пункт теоретически может быть актуален и для полей, описывающих PK. Особенно если такие поля отличаются по
> имени от соответствующих колонок в БД. Но практика показывает, что скорее всего и поле, и колонка будут иметь
> одинаковое имя, например `id`. И описанное ниже для таких полей не потребуется.

Маппинг полей на колонки базы данных во многом имеет природу, схожую с маппингом класса на таблицу. Полю необходимо
указать имя колонки в таблице, по возможности описать constraint'ы и иные характеристики по части DDL. Есть
некоторые нюансы, но их мы рассмотрим в пунктах ниже.

Если поле не имеет какого-то специфичного типа, его имя совпадает с именем колонки, нет дополнительных ограничений
вроде `NOT NULL` и уникальности - маппинг произойдет автоматически и никаких дополнительных действий не требуется.

В иных случаях нам может потребоваться несколько аннотаций, первая из которых - `@Column`. И, в отличие от `@Entity`
или `@Id`, `@Column` совершенно не нужен как маркер, зато может быть необходима информация из его атрибутов. Их
достаточно много:

- `name`. Позволяет указать имя столбца в БД, с которым соотносится данное поле. Необходимо в ситуациях, когда
  автоматический маппинг невозможен;
- `unique`. Указание на уникальность поля. Если `uniqueConstraints` в `@Table` обычно используется для композитных
  уникальных индексов, то этот атрибут актуален для уникальных индексов на одну колонку. Такие индексы в PostgreSQL
  можно указать оператором `UNIQUE` при создании колонки;
- `nullable`. Указывает на наличие у колонки ограничения `NOT NULL`.
- `insertable`. Должно ли значение поля вставляться в таблицу через `INSERT`. Обычно это связано с тем, что одна
  колонка имеет несколько соответствующих полей в entity-классе. Например, может быть представлено два поля для
  связанной по FK сущности - с id сущности и с другим entity-классом. В таком случае одно из полей логично
  обозначить как `insertable = false`. Подробнее к этому вопросу вернемся при знакомстве с отношениями в JPA;
- `updatable`. Аналогично предыдущему пункту, но для UPDATE-запросов;
- `columnDefinition`. При включенной генерации DDL используется, чтобы указать нестандартный тип
  колонки, значение по умолчанию или иную конфигурацию колонки. Фактически значение этого атрибута будет
  подставляться после названия связанной колонки при запросе на создание или изменение таблицы. При выключенной
  генерации DDL может использоваться в целях информирования о нестандартном типе - от банальных массивов
  до `JSON` и `JSONB` (типы, специфичные для PostgreSQL) или чего-то еще более узконаправленного;
- `table`. Специфический атрибут для ситуаций, когда один entity-класс объединяет в себе несколько таблиц БД. В
  пределах курса рассматривать не будем - слишком редкий сценарий;
- `length`. Позволяет указать размер для строковых типов. Например, для `varchar(10)` можно установить значение `10`;
- `precision`. Обозначает ограничение общего количества числовых символов в типах с заданной точностью. В БД это
  обычно `NUMERIC`, в Java - чаще всего `BigDecimal`;
- `scale`. Ограничение количества символов после запятой в числовых типах с заданной точностью.

Как и в случае с `@Table`, атрибуты, относящиеся к DDL, чаще выполняют функцию информирования. В зависимости от
команды могут быть определенные договоренности, какие атрибуты необходимо заполнять, а какие могут оставаться на
уровне БД. Вплоть до того, что будет использоваться только `name` - он по-настоящему необходим для маппинга.

### Маппинг специфических полей

Кроме рассмотренного типового сценария для описания маппинга полей, есть еще ряд аннотаций, которые уточняют правила
маппинга. На данном этапе мы рассмотрим лишь две наиболее популярные из них:

- `@Enumerated`. Предназначается для настройки маппинга Enum-типов. Предлагает два варианта настройки - `ORDINAL`
  (базируется на `Enum#ordinal()`, настройка по умолчанию) и `STRING` - опирается на имя значения енама. Вариант с
  порядковым номером используется по умолчанию и является более легковесным, но часто может сыграть злую шутку - любое
  изменение порядка элементов сломает маппинг. Изменение имени существующего значения - куда более редкий сценарий;
- `@Temporal`. Аннотация для типов даты и времени из `java.util`. Требует указать в атрибутах целевой SQL-тип -
  `DATE`, `TIME` или `TIMESTAMP`. Для типов даты и времени из `java.time` использование этой аннотации не требуется.

Со временем, сталкиваясь с различными узкими сценариями использования, число знакомых вам аннотаций и особенностей
настройки будет увеличиваться. Но на начальных этапах должно хватить уже описанного.

### Pre- и Post-эффекты

Также существует отдельный набор аннотаций, связанных с реакцией на переходы Entity в различные этапы жизненного
цикла. С самим жизненным циклом мы познакомимся в ближайших статьях, пока лишь отметим, что подобные аннотации
существуют и позволяют указать действия, которые необходимо выполнить с сущностью при определенных обстоятельствах -
фактически, это одно из проявления паттерна "Наблюдатель", реализованного в JPA. С самим паттерном мы уже знакомы по
Servlet API.

Существуют следующие аннотации:

- `@PreUpdate`;
- `@PostUpdate`;
- `@PrePersist`;
- `@PostPersist`;
- `@PreRemove`;
- `@PostRemove`;
- `@PostLoad`.

Как можно заметить из названий, они связаны с четырьмя состояниями жизненного цикла сущности. Не все из них являются
тем, чем кажутся, но подробнее об этом поговорим в соответствующей статье.

Сценарии использования обычно вращаются вокруг заполнения служебных полей, как в примере выше, или аудита.
Технически, их можно использовать и шире, но стоит понимать, что JPA - это хоть и высокоуровневая, но все еще
технология для работы с БД. Из чего следует, что не стоит слишком плотно связывать JPA с бизнес-логикой, что
существенно ограничивает область применения описанных аннотаций и некоторых иных возможностей JPA по идеологическим
причинам.

### @Transient

Последняя на сегодня аннотация - `@Transient`. Она используется в случаях, когда на уровне entity-класса необходимо
определить не персистентное поле - такое, которое не нужно с чем-либо сопоставлять в БД.

В примере такое поле определено - оно используется для предоставления определенных данных в нестандартном виде.
Другой распространенный пример использования - поле `fullName` у пользователя, при наличии персистентных полей
`firstName` и `lastName`.

На самом деле возможных сценариев, в которых нужны транзиентные поля, намного больше, но их сложнее описать без
дополнительного контекста. Остановимся на том, что аннотация `@Transient` необходима, чтобы указать JPA, что
определенное поле не должно участвовать в маппинге. В противном случае JPA попытается вставить значение поля в таблицу,
не найдет для него соответствующей колонки и выбросит ошибку.

### Конфигурация и запуск

Мы достаточно подробно разобрались, как объяснить JPA правила сопоставления Java-классов и таблиц базы данных. Но
как сообщить самой JPA о том, что у нас существует определенный entity-класс?

Существует достаточно много способов сделать это в автоматическом режиме посредством конфигурации JPA, persistence
provider или еще более высокоуровневых библиотек. Но эти способы имеют ограничения, особенно в разрезе Java SE.

Базовым и наиболее надежным способом является непосредственное указание entity-классов в `persistence.xml`. Это
несколько утомительно, поскольку любой новый entity-класс или переименование существующего требует правок
конфигурации. Но я не вижу смысла углубляться в автоматизацию данного аспекта на текущем этапе.

Поэтому для запуска и тестирования описанной в начале статьи сущности необходимо указать в конфигурации
`<persistence-unit>` полное имя класса-сущности:

```xml
<class>com.walking.jpa.model.PersonEntity</class>
```

Проверить, что все работает можно следующим образом:

```java
EntityManager em = Persistence.createEntityManagerFactory("Hibernate")
        .createEntityManager();

EntityTransaction transaction = em.getTransaction();

transaction.begin();

var person = new PersonEntity();

person.setName("Иван");
person.setAge(34);
person.setGender(GenderType.MALE);
person.setFavoriteColors(List.of("Красный", "Черный"));

em.persist(person);
transaction.commit();
```

После выполнения данного кода в таблице `person` должна появиться соответствующая запись.

## Заключение

Entity-классы - необходимая, но не достаточная для работы с JPA концепция. Из-за чего к этому моменту может так и не
сложиться целостная картинка взаимодействия. Но уже в следующей статье мы подробнее рассмотрим управляющие конструкции,
которые позволяют использовать entity-классы для получения и записи данных в БД. После чего весь громоздкий
фреймворк начнет понемногу приходить в движение - в том числе в практических заданиях, которые также вернутся со
следующей статьи.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
