# Кэш первого уровня или Persistence Context

Данная статья даст не так много принципиально новой информации. Она появилась в первую очередь из-за популярности
обсуждаемой темы на технических собеседованиях и низкого уровня понимания многими разработчиками, даже имеющими
коммерческий опыт.

Также для нас это является отправной точкой в знакомстве с механизмами кэширования. Намного более плотно мы будем
разбираться с ними в следующей статье, но какие-то общие теоретические сведения рассмотрим уже сегодня.

## Понятие кэширования

**Кэш** (**кеш**, **cache**) - широкое понятие, объединяющее в себе совокупность подходов по обеспечению быстрой
доступности результатов операции и экономии ресурсов на ее обработку, если сам результат заранее известен для указанного
набора входных данных.

В качестве простого примера мы можем рассмотреть, скажем, получение записи из таблицы в БД по id. Если мы знаем, что 
операция получения по id происходит часто, а сами записи в таблицы не меняются или меняются редко - зачем приложению 
каждый раз делать реальный запрос к БД для получения конкретной записи? Логичной оптимизацией кажется сохранение 
записи в памяти приложения - например, в `Map` с `id` в роли ключа. И при очередном запросе записи сначала проверять,
есть ли запись по указанному `id` в `Map` (которая и играет роль кэша). Если есть - возвращать значение из `Map`. 
Если нет - обращаться за записью в БД, добавлять полученное значение в `Map` (на случай дальнейших запросов) и 
отдавать пользователю.

Все что требуется доработать в описанном выше примере - обеспечить гарантию того, что если запись все-таки обновится 
в БД - необходимо удалить ее из кэша. В общем-то, вся сложность кэшей и многообразие их конфигураций по большей части 
связана именно с этим условием. Ведь его невыполнение может привести к тому, что пользователь будет получать данные, 
которые устарели и не соответствуют текущему состоянию системы.

Кэши в различных вариациях и под различные задачи существуют практически везде. Ниже представлены несколько 
разрозненных примеров кэширования на разных уровнях абстракции и для разных задач: 

- Кэши на уровне процессора. Даже такой низкоуровневый (относительно прикладной разработки) электронный компонент имеет 
  собственные механизмы для ускорения операций через кэширование результатов. Более того, процессоры могут иметь 
  независимые кэши для разных задач, некоторые из которых фактически являются многоуровневым каскадом кэшей;
- Кэши в сетевой инфраструктуре. Свои кэши есть почти везде - от DNS-серверов до прокси-серверов, находящихся между
  клиентским и серверным приложениями;
- Кэши уровня приложения. Именно в части разработки мы будем знакомиться с этим позже, но готовые результаты можно 
  найти даже в повседневной жизни. От кэша в мобильных приложениях (с регулярными рекомендациями очистки таких кэшей 
  при возникновении любых проблем) до кэша в браузере, сохраняющего HTML-страницы (головная боль многих мануальных 
  тестировщиков);
- Кэши при компиляции и выполнении программ. Так, в том числе JVM предоставляет собственные механизмы кэширования - 
  например, в рамках JIT-компиляции. В данном случае кэшируются результаты работы целых методов, если JVM определяет 
  метод как часто используемый и не зависящий от какого-либо внешнего состояния*.

> В данном случае имеется ввиду, что результат метода зависит только от переданных параметров, а не каких-то внешних 
> вызовов (сетевых, к файловой системе и т.д.) или полей класса, где описан метод. В принципе, можно говорить, что 
> речь идет о чистой функции.

С точки зрения прикладной Java-разработки, поводом для кэширования обычно является наличие дорогой, но часто 
используемой операции и необходимость сократить время выполнения бизнес-функции, где эта операция используется.

Не уходя в специфику конкретных технологий здесь можно тезисно выделить несколько различных подходов, с большинством 
из которых мы познакомимся на различных этапах курса:

1. Локальный кэш (in-process cache) без сериализации. По сути, любые решения, в которых закэшированные данные 
   остаются в пределах использующего их Java-приложения и хранятся в виде Java-объектов. Описанный выше наивный кэш
   в виде `Map` относится как раз к такому подходу. Сюда же можно отнести и "кэш" первого уровня в JPA, с которым мы
   познакомимся в следующем пункте этой статьи. Есть и специализированные библиотеки для подобного кэширования -
   [Ehcache](https://www.ehcache.org/), [Caffeine](https://github.com/ben-manes/caffeine) и другие. Плюс таких кэшей -
   скорость, ведь они не требуют ни сетевых вызовов для обращения к кэшу, ни затрат на (де-) сериализацию объектов - 
   кэш хранит те же Java-объекты, которые мы в него положили, их же и вернет при обращении. Минусы же вытекают из
   плюсов - такие кэши занимают место в heap'е, плохо подходят для распределенных приложений и любых иных ситуаций, 
   когда изменить данные может не только текущий инстанс приложения, но и кто-то иной - кэш просто не узнает о том, 
   что хранимые данные устарели. Наконец, в случае кэширования изменяемых объектов (без их копирования) существует риск,
   что сам объект будет меняться несколькими потоками одновременно без синхронизации, что может сломать внутреннее 
   состояние объекта;
2. Локальный кэш с сериализацией. Отличается от предыдущего тем, что данные хранятся не как Java-объект, а в 
   каком-то ином формате. Это дает ряд специфических преимуществ, для объяснения которых потребуется давать много 
   справочной информации, но есть и очевидные плюсы - как минимум это гарантирует, что закэшированные данные не 
   будут бесконтрольно мутироваться. Ведь каждое чтение из кэша будет создавать новые объекты в процессе 
   десериализации. Не уверен насчет существования популярных решений, где такой формат работы - основной, но как 
   минимум подобный подход можно наблюдать в определенном (embedded) режиме работы [Hazelcast](https://hazelcast.com/);
3. Удаленные и распределенные кэши. Это совокупность кэшей, которые объединяет их хранение отдельно от приложения - 
   на самостоятельном сервере или кластере серверов. Между отдельным сервером и кластером есть огромная разница как 
   во внутренней структуре решения, так и в надежности, но пока нас это мало интересует. Основное, что сейчас нужно 
   усвоить о кэшах таких типов - они хранят закэшированные данные в собственном хранилище и эти решения всегда 
   требуют ресурсов на (де-) сериализацию - ведь любые обращения в кэш происходят по сети, то есть кэш физически не 
   может хранить Java-объект, с которым мы работаем в приложении. Такие кэши не занимают место в памяти приложений,
   лучше подходят для распределенных систем и потенциально долговечнее - даже если JVM с нашим приложением 
   остановится, кэш никуда не пропадет и будет доступен. Но любые подобные решения требуют затрат на сетевую 
   коммуникацию, (де-) сериализацию хранимых данных приложением и усложняют инфраструктуру продукта - ведь кому-то 
   надо будет управлять дополнительными серверами и установленным на них ПО. К данной группе кэшей можно отнести 
   [Redis](https://redis.io/), упомянутый ранее Hazelcast (в более классических конфигурациях) и т.д.

По сути, это основная информация, которую стоит почерпнуть при первом знакомстве с понятием кэширования. Добавлю 
лишь, что выделяют два основных состояния кэша:

- Холодный кэш. То есть кэш, который не содержит данных или данные заведомо устарели и будут заменены в ходе 
  обращений к кэшу. Для локальных кэшей это характерно на этапе запуска кэша или после его полной очистки 
  (инвалидации). Для удаленных кэшей - на этапе запуска сервера с кэшем или, опять же, после полной инвалидации. В 
  таком состоянии кэш фактически бесполезен для целевого приложения - данных в нем нет и данные приходится получать 
  из оригинального источника, использование которого и хотели закэшировать (БД, удаленный сервер и т.д.). Но это 
  неизбежное состояние, которое нужно пережить - ведь кэш будет постепенно наполняться и переходить во второе 
  состояние (описано ниже). Пока кэш холодный, приложение может работать медленнее и тратить больше ресурсов на 
  выполнение операций - ведь при нормальной работе мы рассчитываем на получение данных из кэша и экономии на дорогих 
  вызовах, которой не происходит;
- Горячий кэш. Это основное состояние работы для любого кэша - он содержит данные и отдает их по запросу. 

## Persistence Context

Мы уже знакомы с `EntityManager` и API, который он предоставляет для работы с Entity-объектами - `persist()`,
`detach()`, `flush()` и другими. И рассматривали сам `EntityManager` в том числе как хранилище для данных, которые 
находятся под его управлением. Этим хранилищем мы и управляли через указанные выше метода. Теперь пришло время 
расширить эту схему и описать то, как она выглядит на самом деле.

Само хранение управляемых EM сущностей в памяти фактически привязано не к `EntityManager` как таковому, а к 
**Persistence Context**. Эта сущность не имеет собственного Java-интерфейса в Java API JPA, но ее (или ее аналоги с 
другими названиями) можно обнаружить как в тексте спецификации JPA, так и в виде интерфейсов или классов в Persistence 
Provider'ах - в том числе в Hibernate.

Каждый `EntityManager` жестко привязан к одному объекту Persistence Context. При этом один объект Persistence 
Context технически может применяться к нескольким физическим объектам `EntityManager`. Эта возможность довольно редко
применяется в целом*, в Java SE приложениях она и вовсе не достижима, так как необходима для обеспечения работы Java EE
контейнеров, которые создают и внедряют объекты EM в классы логики. В Java SE приложениях объекты EM всегда создаются
вручную и описанная возможность не требуется и не предоставляется.

> *Стоит понимать, что в принципе существуют сценарии взаимодействия между транзакциями, объектами EM и persistence 
> context'ом, не затрагиваемые ранее.
> 
> Они преимущественно касаются разработки на базе Java EE и реализованы для работы со спецификой Java EE - в 
> частности, Java EE контейнерами и EJB. В современной разработке это не востребовано и потому же не рассматривается 
> в курсе.
> 
> Тем не менее эти возможности демонстрируют, что с теоретической точки зрения нет жесткой привязки Persistence 
> Context к конкретному объекту EM или одной транзакции (см. Extended Persistence Context).

Однако такой формат отношений объясняет, почему Persistence Context вообще выделяется в самостоятельную сущность, 
пусть и не имеющую отражения в Java API.

Собственно, методы EM для работы с сущностями фактически направлены на взаимодействие с Persistence Context. Что 
даже находит отражение в java-docs для обозначенных методов.

Persistence Context - это набор сущностей, которые можно уникально идентифицировать по их типу и `id`, управляемый 
EM.

В силу этого Persistence Context можно представить как простой кэш, ключом в котором является тип сущности и ее 
идентификатор. Это хорошо видно по методу `EntityManager#find()`, который и принимает на вход тип и `id`. При этом 
стоит понимать, что само представление Persistence Context как кэша - достаточно грубая условность, хоть и 
популярная в среде разработчиков. Задачи этой сущности состоят в промежуточном хранении сущностей для 
обеспечения функциональности JPA в пределах транзакции (или не ограничиваясь ей, если мы говорим об 
Extended Persistence Context).

При стандартном сценарии использования "один контекст - один EM - одна транзакция" общая логика работы Persistence 
Context как с кэшем достаточно прозрачна и была поверхностно описана ранее. Нет особого смысла в пределах транзакции
каждый раз запрашивать объекты из БД, если они уже есть в памяти приложения. Более того, запрос из БД может даже 
помешать корректной работе JPA - ведь в Persistence Context могут лежать entity-объекты, которые еще не были добавлены
в физическую БД (был вызван `EntityManager#persist()`, но не был вызван `EntityManager#flush()`), либо же были 
изменены относительно состояния, известного базе данных. Из-за этого могут наблюдаться некоторые расхождения в 
in-memory данных и записях в БД, что может в отдельных случаях влиять на корректность выборок. Некоторые из таких 
ситуаций были описаны в предыдущих статьях, иногда - вместе с возможными решениями.

> Собственно, я не рекомендую называть Persistence Context кэшем именно в силу того, что он хранит, в том числе, 
> информацию о еще не сохраненных в БД сущностях и обновленное состояние существующих сущностей.
> 
> В то время как кэш, в классическом его представлении, может хранить либо актуальную (относительно источника) 
> информацию, либо устаревшую (и тогда должен быть инвалидирован). Ситуация, когда кэш знает о чем-то, чего сам 
> кэшируемый источник _еще_ не знает - нонсенс.

Подводя итог, обозначение Persistence Context кэшем - удобное в ряде случаев упрощение. Но всегда стоит помнить, что
Persistence Context - часть внутренней кухни JPA. И работает он для обеспечения функциональности JPA, а не является 
самостоятельным инструментом по минимизации запросов к физической БД. Если игнорировать этот факт и сопутствующую 
ему специфику, существует риск упустить побочные эффекты, критические для реализуемой вами функциональности.

## Кэш первого уровня в JPA

Так как средний уровень погруженности разработчиков в возможности и ограничения JPA не слишком высок, сформировался 
целый набор представлений о Persistence Context сугубо как о кэше - даже с названием "кэш первого уровня". И набор 
вопросов на технических собеседованиях, с этим связанных. Некоторые из них разобраны ниже. Не сказать, что это даст 
новую информацию, относительно уже описанного выше, но позволит более корректно понимать, что имеет в виду интервьюер.

### Как включить (или выключить) кэш первого уровня?

Вопрос исходит из того, что JPA определяет возможность существования кэша второго уровня (second-level cache). Мы 
будем разбирать это более подробно в следующей статье. Это действительно кэш и он требует дополнительной 
конфигурации и подключения, если необходим.

Но Persistence Context - это не совсем кэш и он не всегда работает по тем правилам, которые разработчик привык 
ожидать от кэша. Хранение им данных о сущностях - необходимость, без которой невозможна реализация многих возможностей
JPA, описанных ранее. Без промежуточного хранения данных JPA в принципе не сможет работать в привычном нам виде. 
Соответственно, разработчик не может никак влиять на "включение" или "выключение" данного "кэша". Мы можем настраивать
`EntityManager` и другие сущности через публичный API. Можем настроить те или иные стратегии синхронизации данных в
Persistence Context'е и физической БД. Но все это укладывается в API, предоставляемый спецификацией JPA или конкретным
Persistence Provider'ом в лице Hibernate или иной реализации. 

### К чему привязан кэш первого уровня?

Здесь вопрос также исходит из аналогий с кэшем второго уровня. Традиционный ответ на этот вопрос - "кэш первого 
уровня привязан к EM", если разговор идет в разрезе JPA, или же к `Session`, если вопрос был задач в разрезе Hibernate.

Для большинства ситуаций это будет справедливо. Как было отмечено выше, между `EntityManager`, транзакцией и 
Persistence Context обычно используется связь One-to-One и тогда Persistence Context будет существовать в пределах
существования `EntityManager` (или до вызова `EntityManager#close()`).

Однако вместе с тем существует техническая возможность существования Persistence Context'а, к которому обращаются 
несколько объектов EM. Даже в таких ситуациях они не должны делать это конкурентно, из-за чего такая возможность - 
лишь особенность реализации. Но это формально нарушает жесткую привязку одного контекста к одному объекту EM.

Кроме того, часто `EntityManager` ассоциируется с одной транзакцией. Из-за чего фактически имеется ввиду жесткая 
связь между конкретным Persistence Context и конкретной транзакции. Однако снова вспоминаем про Extended Persistence 
Context, который распространяется за пределы транзакции.

Итого, ответ "Persistence Context привязан к одному EM и, соответственно, к одной транзакции" будет справедлив в 
большинстве случаев. Но абсолютно некорректен с формальной точки зрения.

Корректнее рассуждать в обратном направлении. Объекты EM могут быть ассоциированы с Persistence Context. И 
Persistence Context может передавать свои изменения в физическую БД только при наличии активной транзакции. В 
зависимости от окружения и настроек, Persistence Context может быть фактически ограничен одной транзакцией, 
либо же существовать самостоятельно и использовать транзакции только для передачи данных в БД.

### Что является ключом кэша первого уровня?

Вопрос рождается отчасти из желания понять, насколько абстрактно кандидат в принципе понимает термин "кэш", отчасти 
из существования "кэша запросов" в Hibernate, в котором принцип работы отличается от кэшей первого и второго уровней.

Стандартный ответ - ключом является `id` сущности. Более корректный ответ, как мы знаем из описанного выше - "тип 
сущности и ее `id`".

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
